#!/usr/bin/python
"""
Usage: tarantula.py

Modify the variables inside the Setup section.

    <> numTests is the number of times tarantula should call the random
        tester
    <> randTester should be the path to a random tester that takes as
        the its only command line argument a number which it uses as a
        random seed for test generation.  The randTester should return
        or exit with 1 in failing test cases or 0 in passing cases.
    <> progFile is the path to the source file where tarantula is
        searching for suspicious code.  progFile should be compiled
        with gcov enabled (use the "-coverage" flag when compiling with
        gcc/g++), and the randTester should run tests on the compiled
        code.
    <> gcdaFile is the path to the .gcda that gvoc produces when running
        "gcov progFile".
"""

import subprocess
import os


#############################
#          Setup
#############################

numTests = 4000                 # Number of random tests
randTester = "./testtarantula"  # Path to the random tester
progFile = "./dominion.c"       # Path to the suspicious source code
gcdaFile = "./dominion.gcda"    # Path to gcda file generated by gcov


#############################
#          Main program
#############################

# gcov outputs too much to stdout.  Redirect to null to speed things up
DEVNULL = open(os.devnull, 'wb')

# Run the random tester once
p = subprocess.Popen([randTester, "0"], stdout=DEVNULL, stderr=DEVNULL)
# Let the tester finish before continuing
p.wait()
if p.returncode:
    print("Error: Could not open random tester \"" + randTester + "\"")
    exit(1)
# Run gcov to create the coverage report
p1 = subprocess.Popen(["gcov " + progFile], shell=True,
                      stdout=DEVNULL, stderr=DEVNULL)
p1.wait()

# Figure out how many lines are in the coverage report
file = open(progFile + ".gcov", "r")
numLines = len(file.read().split("\n")) - 1
file.close()

# Delete the gcda file to clear line coverages for this test
subprocess.call(["rm " + gcdaFile], shell=True, stdout=DEVNULL,
                stderr=DEVNULL)

# Keep track of the number of passing and failing tests and how many
# times each statement is executed for in both cases
numFailTests = 0
numPassTests = 0
failLineCounts = [0] * numLines
passLineCounts = [0] * numLines

# Run the tests. i is the random seed being passed to the tester
for i in range(numTests):
    # Run the random tester and call gcov to create data
    proc = subprocess.Popen([randTester, str(i)], stdout=DEVNULL,
                            stderr=DEVNULL)
    proc.wait()  # Let the tester finish before continuing
    testFailed = proc.returncode
    proc1 = subprocess.Popen(["gcov " + progFile], shell=True,
                             stdout=DEVNULL, stderr=DEVNULL)
    proc1.wait()

    # Figure out which lines were executed in the current test
    file = open(progFile + ".gcov", "r")
    data = file.read().split("\n")
    file.close()

    # Delete the gcda file to clear line coverages for the next test
    subprocess.call(["rm " + gcdaFile], shell=True, stdout=DEVNULL,
                    stderr=DEVNULL)

    if testFailed:
        numFailTests += 1
    else:
        numPassTests += 1

    # If the statement was executed, add 1 to the appropriate location
    # in failLineCounts or passLineCounts
    for j in range(numLines):
        if (data[j][8] != '-') and (data[j][8] != '#'):
            if testFailed:
                failLineCounts[j] += 1
            else:
                passLineCounts[j] += 1

# Create an array to hold the suspiciousness values of each line
suspiciousness = [0] * numLines

# Print the number of passing and failing tests
print("Number of passing tests: " + str(numPassTests))
print("Number of failing tests: " + str(numFailTests))

# Calculate the suspiciousness of each line
for i in range(numLines):
    if ((failLineCounts[i] != 0 or passLineCounts[i] != 0) and
            (numFailTests != 0) and (numPassTests != 0)):
        suspiciousness[i] = failLineCounts[i] / float(numFailTests) / \
            (passLineCounts[i] / float(numPassTests) +
                failLineCounts[i] / float(numFailTests))

# Remove the first five lines - they don't correspond to the code
suspiciousness = suspiciousness[5:len(suspiciousness)]

# Add an index to each line to keep track of line number after sorting
for i in range(len(suspiciousness)):
    suspiciousness[i] = [suspiciousness[i], i + 1]

# Sort in order of decreasing suspiciousness
suspiciousness = sorted(suspiciousness, reverse=True, key=lambda s: s[0])

# Print the suspiciousness of each suspicious line in descending order
for i in range(len(suspiciousness)):
    if (suspiciousness[i][0] > 0):
        print('Line: ' + str(suspiciousness[i][1]) +
              "\t Suspiciousness: " + str(suspiciousness[i][0]))
